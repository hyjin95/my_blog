---
description: 2020.08.24 - 18일차
---

# 18 Days - 추상클래스, 인터페이스, 형전환, 생성자, 상속과 다향성

### 사용 프로그램

* 사용언어 : JAVA(JDK)1.8.0\_261 : Oracle.com
* 사용Tool \
  \- Eclipse : Eclipse.org\
  \- Toad DBA Suite for Oracle 11.5

## 필기

### 클래스

* 필드(멤버변수 등..)
* 메서드 : 메서드이름(파라미터){구현문, 제어문}, 호출시 첫 문자가 소문자로 표시된다.

### 파라미터

* 메서드의 ( )안에 사용되는 객체, 파라미터에 따라 메서드가 달라질 수 있다.
* 메서드의 파라미터에 전역변수가 올 수 도 있고, Object가 올 수 도 있다.
* 사용자의 요청, 입력 역할

### 변수

* 멤버변수(Heap, 메서드의 파라미터 자리에 올 수 있다.)
* 지역변수(Stack, 영역밖에서 사라진다.)

### 추상클래스 & 인터페이스

|        **추상클래스**        |         **인터페이스**        |
| :---------------------: | :----------------------: |
|         extends         |        implements        |
|       단독 인스턴스화 불가능      |       단독 인스턴스화 불가능       |
|         결합도가 높다.        |         결합도가 낮다.         |
| 일반&추상메서드(abstract), 생성자 |           추상메서드          |
|        구현체 클래스 필요       |          구현체 클래스 필요      |
|        파라미터, 리턴타입       |           파라미터           |
|         변수를 갖는다         |        변수를 가질 수 없다.      |
|   날개 : 오리, 참새, 독수리...   |     날개 : 오리, 비행기, 드론 ... |
|          추상적이다.         |         더 추상적이다.         |

* 역할\
  \- 개발가이드(구현목록, 메뉴얼)\
  \- 결합도가 낮다 -> 독립성 up -> 단위테스트가 가능 -> 통합테스트가 가능 -> 납품 가능
* 인터페이스가 결합도가 낮은, 더 추상적인 개념이다. 조립(클래스쪼개기)에 사용된다.
* 추상 클래스와 인터페이스 중심의 코드를 작성해야 재사용성, 이식성이 좋아진다.
* **추상클래스 변수 == new 구현체클래스( );**
* **인터페이스 변수 == new 구현체클래스( );**
* ex) ArraList인터페이스의 Vector 구현클래스는 Object에 값을 담아온다.
* Animal : 추상클래스, 인터페이스, 사자 : 구현체메서드\
  \- 클래스 중에는 인스턴스를 만들면 안되는 것도 있다. Lion, Tiger 객체를 만드는 것은 이해되지만 Animal은 정확히 어떤 객체인지 결정할 수 없다. 색, 크기, 다리 갯수 같은 것을 결정할 수 없다. = 추상클래스, 인터페이스
* 참고 : Animal.java, ArrayListTest.java

### List 인터페이스, Vector, ArrayList구현클래스

|      Vector      |     ArrayList    |
| :--------------: | :--------------: |
|    멀티스레드에서 안전    |    싱글스레드에서 안전    |
|   읽기쓰기 속도가 느리다.  |   일기쓰기 속도가 빠르다.  |
| copyinto메서드가 있다. | copyinto메서드가 없다. |

* List( i )
* Read || Write의 역할을 한다.
* 배열과 비슷하지만 타입이다른것도 담고, 가변적이며, 끼워넣기가 가능하다.
* List.add  : add에는 order, 순서가 있다.
* List의 리턴타입은 Object로, 클래스도 담을 수 있다.
* Vector는 멀티스레드에서 안전하다.\
  \- 속도가 느리다. 스레드 경쟁이 일어난다. 공용화장실 = wait
* list 는 싱글스레드에서 안전하다.\
  \-  방에 한명만 허락한다. 속도가 빠르다. 스레드 경쟁이 없다. 내 차의 네비게이션 
* List인터페이스는 util에 있는 것을 사용한다.
* 내 안에 있는 타입을 <>안에 직접 써주면 타입체크를 별도로 하지 않는다. = 제네릭 \
  \- 선언부에는 반드시 써야하고 생성부에서는 생략가능하며, 다이아몬드 연산자는 작성 = 오른쪽항\
  \-** Vector v = new Vector( ); Vector v = new Vector<>( );**  : 권장사항
* 참고 : ZipCodeSearch.java

### 추상메서드

* 메서드이름( );  : 구현문, 제어이 없다. { }X
* 반드시 구상, 구현체 메서드로 overriding되어야 사용할 수 있다.

### 구현체 클래스

* 추상메서드를 갖고있는 추상클래스, 인터페이스에게 꼭 필요한 존재
* 추상메서드는 구현체 클래스, 구상메서드가 있어야만 존재할 수 있다.
* 구현체 클래스를 불러와 사용하거나, 클래스안에서 직접 추상메서드를 overriding해서 사용한다.
* 변수를 갖는다.

### **인스턴스화 & 생성자**

* **A a = null ;  : 선언만, a는 Candidate상태, 갱신준비가 된 실선이 없는 풍선**
* 메서드의 파라미터에서 선언될 수 있다. = void method(Dog d){ }
* **a = new A( );  : 생성자 생성 및 호출 -> Heap에 비로소 기록된다.**
* NullPointException에러가 발생하면 인스턴스화 부분을 살펴보자.
* 개체의 LifeCycle을 알고있어야 언제 갱신할지를 알 수 있다.
* 호출시 첫 문자가 대문자로 표시된다.

### 상속

* a is a b
* 소나타는 자동차다. O = Sonata extends Car
* 자동차는 소나타다. X
* extend로 상속을 표시한다.
* 자식클래스는 부모클래스의 것을 호출할 수 있지만, 부모에서 자식의 것은 호출할 수 없다.
* 자식이 부모에게 의존한다, 부모에게 간섭받는다. 결합도가 높아 단위 테스트가 불가능하고, 그러므로 통합테스트가 불가능하다. = 재사용성이 떨어진다. -> 추상클래스와 인터페이스를 사용하는 이유
* 모든 클래스의 부모클래스는 Object를 제공하고 있다. 모든 일반 클래스의 부모 클래스이다.
* 타입 : Object > Animal > Dog, Cat
* 자식클래스 Dog 와 Cat이 부모클래스 Animal을 갖고, Animal은 Object를 부모클래스로 갖는다.
* 참고 : Animal.java, Car.java

### 형전환

* 왼쪽항 = 오른쪽항
* 왼쪽항 > 오른쪽항 : 일반적인 형전환
* 왼쪽항 < 오른쪽항 : 강제 형전환, 타입을 맞춰야한다. = 캐스팅연산자 : (타입)
* 변수(1값,1타입) -> 배열(n값,1타입,1저장) -> 객체배열 (n값,1타입,n저장,끼워넣기x,크기변화x)\
  \-> 자료구조형을 이용하면 끼워넣기, 크기변화가 가능해진다. = ArrayList인터페이스의 Vector\
  \-> 타입이 Object이다. 단, 꺼내도 Object타입이므로 사용하려면 캐스팅연산자로 타입을 맞춰주는것이 일반적이다.
* 참고 : Car.java

### 비교연산자

* equals메서드 : 그 변수가 가리키는 객체가 같은것인지를 비교하는 것
*  \==                    : 그 변수들의 주소번지 값이 같은지를 비교하는 것
* instaceof         : 그 변수들으 인스턴스 타입을 비교하는 것

### DB연동 - S|I|U|D

* 사전준비 : 드라이버 설정(ojdbcd.jar) = 제조사 설정\
  \- ClassNotFoundExcaption이 일어나는 부분\
  \- 드라이버(제조사)의 설정에 따라 SQL이 달라질 수 있다.
* **Connection** ( I )\
  \- 필수 인터페이스\
  \- 연결통로 확보\
  \- 파라미터 : ip, port, user, pw가 반복된다.\
  \- **Connection con = DriverManager.getConnection(파라미터 4개);**\
  \- DriverManager은 Static메서드라 대문자로 시작한다.\
  \- getConnection한 객체를 con에 주입한다. = 객체주입법
* **PreparedStatment** ( I )\
  \- SQL문을 나르는 전령\
  \- DB에 들어가기위해 (ip, port, user, pw)가 필요하다.\
  \- 연결통로인 Connection에 의존한다, 없으면 들어갈 수 없다.\
  \- 같은 인터페이스더라도 사용자의 요청, 입력에 따라 다른 값을 나른다. (조회, 입력, 수정, 삭제)\
  \- **PreparedStatment pstmt = con.PreparedStatment(sql.toString( ));**\
  ****- \_.toString( )  :** **UI 솔루션을 자바코드로 말아서 사용할 때 사용한다.\
  \- I|U|D -> pstmt.excute-( );\
  \- S -> pstmt.excuteQuery( );
* **SELECT사용시**\
  ****- row는 갯수가 정해지지 않았다. n개 -> while문이 필요\
  ****- **ResultSet** ( I ) 필수\
  \- ResultSet인터페이스의 **next( ):boolean** 메서드로 oracle의 Cuser를 조작한다. 반환값 : T || F\
  \- Curser의 그 위치에 그 값이 있니? -> 네,true || 아니오,False\
  \- Curser의 디폴트 위치 : Header의 밑\
  \- 리턴타입이 ResultSet이다. = 수동 카메라\
  \- 요새는 ORM(Object Relation Mapping)의 myBatis를 사용한다. = 디지털카메라

## 응용

### 인스턴스화, 추상클래스, 인터페이스, 상속, 구현체클래스, 메서드 overriding

```java
A a = null;
  a = new B();
```

* 1번 : A타입의 a변수는 Candidate 상태
* 2번 : A타입 a변수는 B풍선(영역)을 갖는다. -> A타입이므로 A영역 밖은 호출할 수 없다.
* A와 B는 다른 타입이다.
* 성립조건 :** A == 구현체클래스, 추상클래스, 인터페이스  &&  B == 구현체클래스**
* A타입이 추상적이다.
* A == 추상클래스  ||  인터페이스 라면, 메서드 overriding해서 재정의 해야만 한다.
* 참고 :  Car.java

