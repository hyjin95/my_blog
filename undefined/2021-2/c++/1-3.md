---
description: 2021.10.18
---

# 출석 수업(1장-3장)

{% file src="../../../.gitbook/assets/Cpp출석수업.pdf" %}

### C++소스 프로그램

```cpp
#include <iostream>

int main()
{
    //표준 출력 스트림으로 출력
    std::cout << "나의 첫 번째 C++ 프로그램" << std::endl;
    return 0;
}
```

* 주석
  * 컴파일러가 컴파일 하지 않는 부분
* 선행처리기
  * \#include -
    * "" : 경로
    * <> : C++표준라이브러리의 헤더파일
* std::cout
  * 출력 객체 cout
* &#x20;std::endl
  * endl : end of line
* C++의 경우 Main함수는 return을 생략해도 컴파일시 기본 return값이 있는 것으로 컴파일 된다.&#x20;

### 입출력 스트림

* cin
  * 공백으로 문자를 구분한다.
  * 공백을 포함해 출력하고 싶다면 cin.get 등을 사용해야한다.

### 명칭공간

* 위에서 사용된 cout, endl또한 표준 C++라이브러리 명칭공간 std에 작성되어 있다.

### 변수

*   C언어에서 변수의 이름으로 첫 문자는 영문자나 \_밑줄 문자가 올 수 있다.

    밑줄문자외의 특수문자는 사용할 수 없다.
* C++ 11부터는 다국어 문자를 변수명으로 사용할 수 있다.
* 변수의 초기화 형식은 네가지가 있다.
  * int z=0;
  * int z(0);
  * int z = {0};
  * int z{0};
* 자료형 추론
  * auto 자료형은  컴파일러가 초기화 되는 값의 자료형으로 변수의 자료형을 추론한다.
  * Template사용시 유용하게 사용된다.
* Const
  * 변수 값을 절대적으로 고정하기 위해 사용한다.

### 배열

```cpp
#include <iostream>
using namespace std;

int main()
{
    int data[10] = { 10, 23, 5, 9, 22, 48, 12, 10, 55, 31 };
    int  ㈀;  // data의 첫 번째 데이터를 max로 가정함

    cout << "데이터 : " << ㈁;  // 0번 데이터 출력
    for ( ㈂ ) {    // 나머지 9개의 데이터 비교
        cout << "  " << ㈃;     // i번 데이터 출력
        if (max < ㈃ )    // i번 데이터가 max보다 크면 비교
            max = ㈃;     // max를 i번 데이터로 바꿈
    }
    cout << endl << endl;
    cout << "배열의 최댓값 : " << max << endl;
    return 0;
}
```

*   max{data\[0]}

    data\[0]

    int i;i<10;i++

    data\[i]

    data\[i]

    data\[i]

### 포인터

* 값의 주소를 가리키는 변수를 말한다.
* TypeName \*ptrVar
  * TypeName 자료형
  * ptrVar 변수이름
* int\* a,b;
  * a는 정수형 포인터이고, b는 정수형 변수이다.
  * int \*a,b; 와 같다.
* 포인터 변수의 유효한 대상
  *   ptrVar = \&var;

      포인터 변수 ptrVar 변수 var의 주소를 가리킨다.

### 포인터 예제

```cpp
#include <iostream>
using namespace std;

int main()
{
  int  a = 10, b = 100;
  int  ㈀; 	 // 포인터 ptr을 선언한 후에 a의 주소를 넣는다.

  cout << "ptr이 가리키는 곳의 값 : " << ㈁ << endl;
  ㈂ = 20;   // ptr이 가리키는 곳에 20을 저장
  cout << "변수 a의 값 : " << a << endl;
  ㈃;         // ptr이 b를 가리키게 함
  cout << "변수 b의 값 : " << *ptr << endl;
  return 0;
}
```

*   \*ptr = \&a;

    \*ptr

    \*ptr

    ptr = \&b;
* 위 예제에서 알 수 있듯 포인터의 단점은 누가 어디서 값을 수정했는지 알 수 없다는 것이다.

### 포인터의 동적 메모리 할당

```cpp
int *ptrVar
ptrVar = new TypeName[n];
```

* 배열형식으로 n에는 정수, 정수형변수 또는 정수형 수식이 올 수 있다.

```cpp
ptrVar = new TypeName; 
delete ptrVar;

ptrVar = new TypeName[n]; 
delete []ptrVAr;
```

* new로 생성되어 동적 메모리의 할당을 받은 변수는 반드시 사용 필요가 없어진 시점에 delete로 삭제되어야 된다.
* 위와 같이 삭제하면 포인터가 참조하는 주소의 데이터는 삭제되지만 포인터는 할당된 빈 메모리는 가리키고 있다.

```cpp
ptrVar = nullptr;
```

* 포인터의 초기화

### 동적 메모리 할당 예제

```cpp
#include	<iostream>
using namespace std;

int main()
{
    char* sPtr;
    int  maxSLen;
    cout << "단어의 최대 길이를 입력하시오 : ";
    cin >> maxSLen;
    ㈀   // maxSLen개의 문자를 저장할 메모리 할당
    cout << "단어를 입력하시오 : ";
    cin >> sPtr;
    for (char* p = ㈁ ; ㈂ ; ㈃)    // p를 이용하여 모든 문자 처리
        ㈄   // 소문자를 대문자로 변환
    cout << sPtr << endl;
    ㈅ // ㈀에서 할당한 메모리 반환
}
```

*   sPtr = new char\[maxSLen+1];

    \=sPtr

    \*p!=’\0’  (\*p와 같다)

    p++

    if(\*p>=’a’&&\*p<=’z’)\*p+=’A’-‘a’;

    delete\[] sPtr;
*   ㄱ의 +1은 enter를 입력시 null문자('\0')를 위한 자리이다.&#x20;

    이 값으로 문자열의 끝을 인식할 수 있다.
* sPtr은 문자열의 첫 번째 방을 가리킨다.
*   C,C++에서 0은 참,거짓을 가리킨다.

    문자 p가 null('\0')이면 for문이 종료된다.

### l-value 참조

* 포인터의 단점들을 보완하는 것으로 참조(reference)가 생겨났다.
*   기존에는 l-value 참조만 존재했지만 C++ 11부터 r-value 참조가 등장한다.

    l-value : 실체가 있는 대상에 대한 참조

```cpp
TypeName &refVar = varName;
```

* l-value 참조의 선언
* 포인터와 다르게 사용시 varName이 들어갈 자리에 refVar를 기입한다.

### 참조 예제

```cpp
#include  <iostream>
using  namespace  std;

int main()
{
    int  a = 10, b = 20;
    ㈀  // a를 참조하는 참조 변수 aRef를 선언
    cout << "a의 값 : " << a << endl;
    cout << "aRef가 참조하는 값 : " << aRef << endl << endl;
    aRef = 100;
    cout << "a의 값 : " << a << endl;
    aRef = b;
    cout << "a의 값 : " << a << endl;
    return 0;
}
```

* int \&aRef = a;

