---
description: 2021.10.23 토요일
---

# 2강 C++언어의 기초(1)

### 키워드

* C++ 언어에서 미리 용도를 정해준 단어로 예약어 라고도 한다.
* 정해진 용도가 있다.
* using, namespace, int, return, ....

### 식별자

*   대상을 구분하기 위한 이름

    변수, 함수, 클래스 등의 이름
* 규칙
  *   첫 자는 비숫자 문자를 사용한다.

      C++ 11부터는 다국어 문자를 허용한다.
  *   이후 문자는 비숫자 + 숫자를 허용한다.

      밑줄문자, 영문 대소문자, 숫자
  * 길이제한 X
  * 특수문자 , 연산자X
  * 키워드 X
*   Camel case : myName

    Upper Camel case(Pascal case) : MyName

### C++ 자료형&#x20;

* 기본 자료형&#x20;
  * 정수자료형(char,int,short,long,bool, ...)
  * 실수자료형(float, double, long double)
*   이진법의 고정소수점 - 일반적인 실수 표현법

    이진법의 부동소수점 - 1.2 x10의3승 같은 실수 표현법
* 복합 자료형
  * 배열, 구조체(struct), 클래스, 열거형(enum), 공용체(union)
  * 포인터, 참조

### 정수 자료형

* 고정소수점 방식의 숫자 표현으로 값의 범위를 벗어나지 않도록(overFlow)를 주의해야한다.
* 문자 자료형
  * char(8bit)
* 정수 자료형
  * int(32bit), short(8bit), long(16bit), long long(32bit)
*   자료형의 앞에&#x20;

    signed : 양수, 음수를 모두 표현한다.

    unsigned : 양수만 표현한다.
* 참/거짓을 표현하는 자료형
  * C++언어에서 ==0은 참, !=0은 거짓으로 한다.
  * bool : true, falsle를 저장한다.

### 실수 자료형

* 부동 소수점 방식의 숫자 표현
*   float(4byte)

    부호 1bit, 지수 8bit, 가수 23bit
*   double(8byte)

    부호 1bit, 지수 11bit, 가수 52bit

### 상수의 표현 - 리터럴(literal)

* 정수형 리터럴의 표현
  *   숫자를 표현하는 문자 + 부호 만으로 표현

      16진수라면 영문자 a-f(A-F)사이의 문자도 허용한다.
  * 접두사를 사용한 진법 표현
    * 10진수는 접두사가 없다.
    * 2진수 : 0b\~(ex - 0b010111)
    * 8진수 : 0\~ 또는 \\\~ (ex - 0237)
    * 16진수 : 0x\~ 또는 \x\~ (ex - 0x9f)
  * &#x20;접미사를 사용한 정수 리터럴의 자료형 지정
    * int : 접미사 x
    * unsigned int : \~u
    * long : \~L
    * unsigned long : \~ul
    * long long : \~ll
  * 문자 리터럴의 표현
    * ' ' 사이에 기입한다.
      * 'A' 문자 A는 ASCII코드에 정수 65에 해당한다.
    * 8진수, 16진수 문자코드로 표기한다.
      * '\101' : 65의 8진수 표현 = 'A'
      * '\x41' : 65의 16진수 표현 ='A'
* 실수 리터럴의 표현
  * 소수점을 갖거나 지수표현으로 표시되는 리터럴
  * double 형
    * 19\.  : 실수형 리터럴이다. 소수점이 있으므로
    * 19.0
    * 12e2 : e는 10의 제곱이므로 12 x 10의2승
    * 1.2e+3 : 1.2  x 10의3승
  * float 형 (f접미사)
    * 19.0f
    * 12e2f

### 변수

* 프로그램이 실행되는 동안 기억하고 있어야하는 값들이 저장되는 메모리 영역
* 이름이 지정되어야 한다.
* 사용 전에 미리 선언 되어야 한다.
* 선언위치
  * 함수 내부 : 지역변수
  * 함수 외부 : 전역변수
* 선언 형식
  *   자료형이름 변수의이름;

      TypeName name;
  *   동일 자료형의 여러 변수는 한번에 선언이 가능하다.

      TypeName name, name2,name\_3,....
* 초기화
  * int name = 0;
  * int total(0);
  *   int total = {0}; 또는 int total{0};

      C++ 11부터 허용되는 방식이다.
  *   int x = 1.5;

      위와같이 int형 x를 실수로 초기화 하면 1로 초기화된다. 소수 부분은 버린다.
  *   int total;

      short x{total};

      위와 같은 축소변환은 에러가 발생한다.
* 자료형 추론
  * 변수를 초기화할때 초기화 하는 값의 자료형으로 변수의 자료형을 추론한다.
  *   auto i(10);

      int i(10);과 동일하다.

### 변수의 한정어 - const

*   const : 상수, 고정된 값

    변수의 값을 고정해 수정할 수 없도록한다.

    초기화 시점에서만 값을 정할 수 있다.
* const double PI {3.14159};
* 과거에는 매크로 상수(#define)을 사용해 컴파일시 해당 변수는 해당 값으로 모두 변환하는 방식을 사용했지만 (#define PI 3.14159) const이후로는 권장되지 않는다.

### 변수의 한정어 - constexpr

*   constexpr : 상수 수식

    해당 값을 컴파일 시 평가한다.

    실행 도중 값을 평가하는 것 보다 효율적인 동작이 가능해진다.

```cpp
int a;
std ::cin >> a;
const int b = 20;
const int C1 = a;      //cin으로 입력된 a로 초기화되는 변수
constexpr int C2 = a;  //컴파일 당시 a값이 없으므로 에러가 발생한다.
constexpr int C3 = b;  //컴파일 당시 b값이 있으므로 초기화가 가능하다.
```

* 시점에 주의한다.

```cpp
constexpr int fac(int n){//n! = nx(n-1)x(n-2)x.....x1
    return n > 1 ? n*f(n-1) : 1; //n>1이면 n*f(n-1)재귀호출, n <=1이면 1return
}

void f(int x){
    constexpr int a = fax(4); //컴파일 시에 정해진다.
    int b = fax(x); //실행 중 계산된다.
}
```

* constexpr 함수
  *   함수의 모든 인수가 constexpr인 함수를 말한다.

      컴파일 시에 값을 구할 수 있다.

### 변수의 life time

* 변수의 유효기간
* 자동변수
  * 생성시점 : 함수 바디(블럭)이 시작될 때
  * 소멸시점 : 함수 바디가 종료될때
  * 지역변수가 해당된다.
* 정적변수
  * 생성시점 : 프로그램의 시작
  * 소멸시점 : 프로그램의 종료
  * 전역변수 및 정적변수(static변수)가 해당된다.

### 변수와 상수의 사용예시

```cpp
#include <iostream>
using namespace std;

int main(){
    const double PI{3.14159};
    double radius;
    
    cout << "원의 반경을 입력하시오 : ";
    cin >> radius;
    double area = radius * radius * PI;
    cout << "원의 면적 = " << area << endl;
    
    return 0;
}
```

### 산술 연산자

* 2항 연산자
  *   사칙 연산자 : +,-,\*,/

      정수형 끼리의 사연산은 정수형을 반환하고, 실수형끼리는 실수형을,

      실수형 정수형의 사칙연산은 정수형을 실수형으로 변환해 계산된다.

      3 /  2 = 1&#x20;

      3.0 / 2.0 = 1/5
  *   나머지 연산자(나머지를 구하는 연산자) : %

      5 % 3 = 2

      \-5 % 3 = -2

      5 % -3 = 2

      \-5 % -3 = -2

      C++에서는 나눠지는 수의 부호가 나머지의 부호가 된다.
* 단항 연산자
  *   증감 연산자 : ++, --

      a = 10일때

      b = ++a; > a는 11 b는 11

      b = a++; > a는 11 b는 10, 대입 후 ++된다.
  * 부호 연산자 : +, -

### 대입 연산자

* 대입 연산자 =
*   a는 double, b는 int형일때

    a = b= 0; > a는 0, b는 0

    a = b = 1.5; > a는 1, b는 1
* 복합 대입 연산자
  *   이항 연산자 + 대입연산자

      \+=, -=, \*=, /=, %=, <<=, >>=
  * a +=b; a+b를 a에 대입한다.

### 관계 연산자

* true or false를 반환한다.
* \>, <, >=, <=, ==, !=

### 논리 연산자

*   논리 합 || :  조건 중 하나라도 true면 true 값 반환

    논리 곱 && : 조건중 하나라도 falsle면 false 반, 앞 조건이 falsle라면 뒤 조건은 계산하지 않는다.

    부정 !
*   a=10, b=-5일 때

    a > 0 && b > 0 : false

    a > 0 || b > 0 : true

    a < 0 && --b < 0 : false, b = -5, 앞 조건이 true였다면 b=-6이된다.

    !(a > 0) : false

### 비트 단위 연산자

* 비트 단위 논리 연산자
  *   논리 합 |

      논리 곱 &

      배타적 논리 합 ^ :  두 값이 같으면 0 다르면 1

      부정 \~
  *   x가 0x35(0011 0101), y가 0xf0(1111 0000)일 때 --16진수

      x | y : 비트 단위로 비교해서 하나라도 1이면 1이다. = 0xf5(1111 0101) 반환

      x & y : 하나라도 0이면 0이다. = 0x30(0011 0000)

      x ^ y : 0xc5(1100 0101)

      \~x : 비트 반전. = 0xca(1100 1010)

```cpp
//좌측 이
unsigned char x = 0b00011101; //2진수, 10진수 29
unsigned char y = x<<2; //y = 01110100, 10진수 116(29x2의2승)

//우측이동
char x = 0b10010100 //-108, 접두사 0b뒤의 1은 부호(음수표현)
char y = x>>2; //y = 11100101, 비는 좌측 두자리에는 부호비트 1이 채워진다, -27(-108%4)
```

* 비트 이동 연산자
  *   좌측 이동 <<

      우측 피연산자에 지정된 비트 수 만큼 좌측 피연산자를 좌측으로 이동한다.

      우측에 새로 생기는 비트는 0

      1bit이동시 2배가 된다. 위 예제는 2bit이동이므로 2의2승 4배
  *   우측 이동 >>

      반대로 좌측 피연산자를 우측으로 이동한다.

      signed형인 경우 부호를 유지하도록 부호와 같은 비트가 좌측 비트에 채워지는데 이는 구현에 따라 다르다.

      위 예제는 2bit이동이므로 2의2승 1/4배

### 조건 연산자

*   조건 ? 값1 : 값2

    조건이 turue면 값1, false면 값2 반환
* 유일한 3항 연산

### 자료형의 형변환 - 묵시적형변환

* 컴파일러가 해주는 형변환 = 묵시적 형 변환
* 연산에서 값들의 자료형이 다르다면 형변환을 통해 맞춰준 다음 연산이 수행되어야 한다.
* 두 값 사이의 연산에서는 우선순위가 낮은 자료형 값이 더 순위가 높은 자료형으로 자동 변환된다.
* 여러 연산으로 구성된 수식에서는 연산자 단위로 변환된다.
* 대입연산자는 값을 저장할 변수의 자료형으로 묵시적형변환한다.
* 오차나 overFlow를 주의하자

### 자료형의 형변환 - 명시적형변환

* 형 변환 연산자
  *   static\_cast

      컴파일 시 수식에 지정된 대로 변환

      static\_cast <변환목표자료형> (형변환대상의 수식)

      static\_cast \<int> (n / 10.0) : 수식(n값을 double자료형인 10.0으로 나눈값)을 int로 변환한다.
  *   dynamic\_cast

      기초 클래스와 파생 클래스간의 포인터, 참조 형 변환이 프로그램 실행 중(동적) 수행하도록 지시
  *   reinterpret\_cast

      포인터를 다른 자료형의 포인터나 정수 자료형 또는 그 반대로 변환
  *   const\_cast

      const지정을 일시 해제
